[ 파일 출력 기본코드 이해하기 ]
    1.  출력 위한 버퍼 생성 (Platform Buffer) : 
        FileOutputStream fos = new FileOutputStream(test.txt);
    
    2.  버퍼에 'a'보관  :
        fos.write('a');
    
    3.  버퍼에 'b'보관  :
        fos.write('b');
    
    4.  한꺼번에 모아서 OS버퍼로 전달        :
        1개씩 데이터를 전달하지않고 일괄처리  :
        fos.flush();
    
    5.  버퍼 삭제 (OS Buffer도 함께 삭제됨) :
        fos.close();

=======================================================================

[ 문자 코드와 ASCII 코드 ]
  - ASCII 코드  : 1Byte(8Bit)로 표현하는 코드
                  영문을 숫자 값으로 표현한 코드
  
  - 문자 코드   : 1개 문자는 ''(홑따옴표)로 표현
                  char 형 자료형으로 표현
                  문자로 연산 수행 X

  - 한글        : 2Byte로 표현
  - 영문        : 1Byte로 표현

    ex) int x = 'A';
        System.out.println(x);
        --------------------------
        출력 결과 : 65
        'A'의 아스키코드 값이 65

    ex) fos.write(x);
        --------------------------
        출력 결과 : 'A'
        문자 편집기이므로 문자로 출력 

    ex) char x = 'A';
        x = x + 1;
        --------------------------
        출력 결과 : 에러

=======================================================================

[ Unicode ]
  - 각국 언어의 코드값이 충돌하지 않도록 만든 코드
  - Unicode 인코딩 방식
      - UTF-8   : 8Bit
                  WEB, 이메일, 일반 텍스트 처리 적합
                  영문 위주 환경 적합

      - UTF-16  : 16Bit
                  Windows시스템, Java프로그래밍 환경 적합
                  다국어 환경 적합

      - UTF-32  : 32Bit
                  데이터베이스, 고성능 텍스트 처리시스템 적합

=======================================================================

[ UTF-16 인코딩 ]
  - 데이터 저장시 모든 문자를 2Byte(16Bit)로 표현
  - 데이터 전달은 1Byte 단위
  - 다국어 환경을 위한 인코딩 방식으로 적합
  - 영문만 사용하는 환경에는 부적합 (영문은 1Byte이기 때문)
  - UTF-8 사용이 더 높음  : 웹 페이지 등 영문 텍스트 처리 환경이 다수이기 때문

    ex) FE FF / AC 00 / AC 01 / AC 02 / 00 41
        - FE FF : 바이트 순서 표기
                  BOM (Byte Order Mark)
                  - FE FF : 빅 엔디언 BOM
                            상위 데이터 바이트를 메모리의 상위 주소에 할당
                            AC 00  ->  AC 00 
                  - FF FF : 리틀 엔디언 BOM
                            하위 데이터 바이트를 메모리 상위 주소에 할당
          
                            AC 00   ->  00 AC
        - 16진수(4Bit)로 이루어짐
        - 16진수 4개로 문자 1개 표현  : 4bit * 4 = 16bit(2byte)로 문자 1개 표현          
        - AC 00 : '가'
        - AC 01 : '각'
        - AC 02 : '갂'
        - 00 41 : 'A'

=======================================================================

[ UTF-8과 UTF-16 인코딩 방식 차이 ]
  1.  UTF-8
        - 한글  : 3Byte로 표현
        - 영문  : 1Byte로 표현
  2.  UTF-16
        - 한글  : 2Byte로 표현
        - 한글이 많은 환경은 UTF-16 적합

=======================================================================

[ OutputStream 대신 사용하는 응용 Stream ]
   FileOutputStream
      - text 파일로 저장    : 값을 문자로 저장
                              문자, 숫자 상관없이 모두 문자로 저장
                              = PrintStream

                              ex) 70 -> '7' '0'으로 저장
                                  80 -> '8' '0'으로 저장

      - binary 파일로 저장  : 숫자 그대로 저장
                              1byte로 표현가능한 수 범위 내에서만 저장가능
                              문자 데이터를 주로 사용하는 웹 개발자에게 활용성X
                              = DataOutputStream

=======================================================================

[ 값 형식 / 참조 형식 ]
  1.  값 형식 (Value Type)
        - 이 형식으로 선언한 변수는 값을 담는 공간이 생성
        - 기본 형식
        - 종류  : byte
                  short
                  int
                  long
                  float
                  double
                  char
                  boolean 등

  2.  참조 형식 (Ref Type)
        - 이 형식으로 선언한 변수는 값을 담는 공간 생성 X
        - 다른 공간의 이름, 별칭으로 사용
        - 참조를 저장하는 변수
        - 기본 형식 x
        - 종류  : String
                  FileOutputStream
                  PrintStream

=======================================================================

[ 객체 ]
  - 자바에서 new 연산자 통해 생성되는 것들
  - 참조 형식
  - 공간 생성 X
  - 의인화되는 역할자
  - 함수가 명령한 것을 버퍼에 수행하는 역할
  - 버퍼가 명령 직접 수행하지 않고 객체가 수행
  - 객체명  : 데이터 공간에 대한 이름이 아니라
              객체 (숨어있는 역할자)에 대한 이름
  - 서비스 함수 : 객체가 제공하는 서비스 함수들을 user가 활용하고
                  나머지 부분은 user가 알필요 없음
  - 캡슐화  : 객체가 제공하는 서비스 함수들을 개발자들이 사용하고
              나머지 부분은 은닉

        ex) FileOutputStream fos;           //   객체명 fos (공간생성x)
            fos = new FileOutputStream();   //   fos가 참조시작
            fos.write('7');

        ex) String A = new String();
            - 문자열 버퍼를 사용하는 객체 A 생성 :  일을 대신해줄 역할자 생성
            - 객체 A의 서비스 함수 :  length()
                                     sort()
                                     concat() 등
            - A : 객체명
            - String  : 객체 형식 (객체 Type)


=======================================================================

[ 문자열 / 문자열 객체 ]
  - 문자열  : 문자 여러개가 열을 이루는 것
             ""(큰따옴표)로 표현
             문자열 끝에는 반드시 null 문자
             null 값 :  0 (\0)
  - 문자열은 기본형식 X
  - 문자열은 객체형식 (참조형식) String
  
    ex) String str = new String("Hello");
        - 객체명    : str
        - 객체형식  : String
        - 객체 str이 제공하는 String 형식의 서비스 함수 : length()
                                                        sort()
                                                        concat() 등

    ex) String A = new String("hello");
        String B = "hello";
        String C = "hello";
        --------------------------------
        A     : B, C와 같은 값을 가지지만 서로 다른 객체
        B, C  : 실행 환경이 문자열 자체를 애초에 객체화
                문자열 자체가 객체
                서로 같은 객체 "hello"를 참조
        A == B      : F
                      비교연산자 == 는 비교대상 객체들이 동일한지 비교
                      A, B 서로 다른 공간 사용 
        B == C      : T
                      같은 객체 "hello"를 참조하므로 서로 객체 동일
        A.eaquls(B) : T
                      equals()함수는 비교대상 값들이 동일한지 비교

=======================================================================