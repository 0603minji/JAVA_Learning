[ WORA 위한 자바코드 특징 ]
  1.  (C++코드) ---(인터프리터)---> (기계어 코드) ---(배포)---> (CPU)
      - C++ 코드가 번역된 CPU와 동일 환경 CPU에서만 실행 가능
      - 호환되지 않는 다른 CPU는 실행 불가
  
  2.  (C++코드) ---(배포)---> (CPU) ---(번역기)---> (기계어 코드)
      - 원시 코드 우선 배포후 실행할때 번역
      - 인터프리터는 컴파일러 보다 수행 성능 떨어짐
      - 컴파일러 함께 사용없이 인터프리터 단독 사용으로 속도 떨어짐
  
=============================================================================

[ 자바의 WORA 수행 과정 ]
  1단계 : 형태소 분석
  2단계 : 구문 분석         - Compiler 작업 부분
  3단계 : 의미 분석         - 어떤 CPU에서도 동일 작업 부분  
  --------------------------------------------------------
  4단계 : 중간 코드
  5단계 : 최적화            - Interpreter 작업 부분
  6단계 : 물리코드          - CPU에 따라 다른 과정

  - 수행성능/속도 : 효과 상승
  - 컴파일러 사용 결과물 : 전체가 한번 번역된 것
                         이후 주구장창 사용
  
  - 인터프리터 사용 결과물  : 결과물 없음
                            사용 필요시마다 번역

  - (JAVA 코드) ---Compiler--->  (중간 코드) ---Interpreter---> (기계어 코드)
                = JDK가 수행     = 바이트 코드    = JRE가 수행
                  - Debugger    = class 파일        - JIT Compiler
                  - Compiler                        - class loader
                                                    - garbage collector

=============================================================================
[ JAVA IDE ]
  - IDE     : Intergrated Development Environment
  - 종류    : eclipse / intellij / vs code

=============================================================================
[ VS Code에서 자바 프로젝트 생성 ]
  - 작성한 소스코드를 저장하는 순간 class 파일 생성
  - IDE가 저장과 동시에 자동 번역 (컴파일)
  - (view) -> (command pallette) -> (create java prj) 선택

=============================================================================
[ 값의 종류 ]
  1.  정수값
      - 크기
          - byte    : 8bit  (1byte)
          - short   : 16bit (2byte)
          - int     : 32bit (4byte)
          - long    : 64bit (8byte)
      - 진법
          - 2진법   : 0b  11010
          - 8진법   : 0   32
          - 10진법  :     26
          - 16진법  : 0x  1A
          - 컴퓨터는 2진수로 결국 연산한다
  2.  실수값
      - 크기
          - float   : 32bit (4byte)
          - double  : 64bit (8byte)
      - 지수표기
          - 126.231
          - 1.26231 * E2
          - 2진수 변환 후 맨 앞의 1 뒤에 소수점 표기
  3.  문자값
      - char  : 문자하나 'a' (작은따옴표)
  4.  진리값
      - boolean : true  (0 이외 모든 수)
                  false (0)

=============================================================================
[ 변수 의미와 Hoisting ]
  - 변수  : 실행환경에게 영향을 줌
            실행환경에게 변수 선언은 메모리에 공간 할당 의미
            자료형에 따라 공간 크기 마련
  - 선언  : 컴파일러에게 영향을 줌
            컴파일러에게 변수인지 함수인지 클래스인지 등을 알려주는 행위
            자료형 표현 필요
  - Hoisting 구조 : 변수 선언 먼저 후 초기화 및 연산 절차
                    ex) int kor1;
                        int kor2;

                        kor1 = 50;
                        kor2 = 60;

=============================================================================
[ 변수명 ]                        
  - 숫자 시작 x
  - 특수 기호 x
  - 공백  x

=============================================================================
[ 정수값의 크기와 범위 ]  
  - 변수  : 값을 담는 공간
  
  1.  int형 변수에 저장가능한 값의 범위
        - int = 32bit (4byte)
        - 32bit는 2^32개 표현 가능
        - 모든 정수는 MSB(Most Significant Bit, 부호비트) 존재
        - 즉, 값 표현 bit 수에서 1bit 제외 필요
        - 즉, int형 변수에 2^22개 표현 가능
  
  2.  nbit 크기 변수에 저장가능한 값 범위
        - max값 : 2^n-1 - 1     (0 제외)
        - min값 : -(2^n-1)-1    (0 제외)
        - 양의 정수값 범위  : 0 ~ 2^n-1 - 1
        - 음의 정수값 범위  : -(2^n-1)-1 ~ -1

=============================================================================
[ 부동 소수점 ]
  - float point
  - 실수값 표현 방법 
      - 고정 소수점 (fixed point)
      - 부동 소수점 (float point)
  
  1.  고정 소수점 표현 방식
      - float형 소수 (32bit = 4byte)
      - 1bit    : MSB 존재
      - 15bit   : 정수부
      - 16bit   : 실수부
      - 정수부가 더 큰값이거나 실수부가 더 큰값일떄에 따라 유동적 표현 불가능

  2.  부동 소수점 표현 방식
      - float형 소수 (32bit = 4byte)
      - 1bit    : MSB 존재
      - 8bit    : 지수부
      - 23bit   : 가수부
      - 표현 대상 실수값을 2진수로 변환
      - 가장 앞의 '1' 뒤에 소수점 이동
      - 소수점 이후 수들은 가수부
      - E의n승 표현 후 n은 지수부

        ex) 12.375
              - 12    = 1100 (2)
              - 0.375 = 0.0110 (2)
              - 1.1000110 * E3      

=============================================================================
[ 파일 출력 ]
  user    --->    java language     --->    < java platform API >
                        +                         - write();
                  java                            - flush();
                  platform API                    
                  (app = java code)                   

                                            < OS API >
                                                - write(~);
                                                - fflush(~);


                                            < 장치 driver >
                                                - int write(){
                                                  }
                                                - int flush(){
                                                  }


                                            < HDD에 작동 >

=============================================================================

[ 출력 버퍼 생성 ]
FileOutputStream fos;
fos = new FileOutputStream(경로);

[ 출력 버퍼로 write 명령 ]
fos.write('a');
  - HDD가 작업 중이므로 바로 보내지않고 손실 방지 위해 버퍼 보관
  - 이후 일괄 처리
  - fos 이름의 버퍼에 a 보관

==============================================================
개체  : 형식, 유형 (실존 x) 
객체  : 실존 O